# Week 3 â€“ Algorithms and Voting

This folder contains my work for **Week 3 of Harvardâ€™s CS50x**, which focuses on algorithms, efficiency, and applying them to real-world style problems like elections.

Week 3 introduces:
- searching and sorting algorithms
- algorithmic complexity (Big O notation)
- selecting the right algorithm for the job
- building and reasoning about voting systems in code

---

## ğŸ“˜ Overview

The key idea of Week 3 is that **how** you solve a problem matters as much as **whether** you solve it.

Two programs can produce the same result, but:

- one may be fast and scalable  
- one may be painfully slow as input size grows  

Week 3 trains you to think about **performance**, not just correctness.

---

## ğŸ§  Core Concepts

### ğŸ” Searching

- **Linear Search**  
  â€“ Look through items one by one.  
  â€“ Time: O(n)

- **Binary Search**  
  â€“ Divide and conquer on sorted data.  
  â€“ Repeatedly halve the search space.  
  â€“ Time: O(log n)

---

### ğŸ” Sorting

Common algorithms introduced:

- **Selection Sort** â€“ repeatedly select the smallest element.  
  - Time: O(nÂ²)

- **Bubble Sort** â€“ repeatedly swap adjacent out-of-order elements.  
  - Time: O(nÂ²)

- (Optionally) **Merge Sort** â€“ divide list, sort each half, merge.  
  - Time: O(n log n)

These algorithms show how different strategies scale very differently.

---

### â±ï¸ Big O Notation

Used to describe algorithm efficiency:

- O(1) â€“ constant time  
- O(log n) â€“ logarithmic  
- O(n) â€“ linear  
- O(n log n) â€“ â€œn log nâ€ (good for sorting)  
- O(nÂ²) â€“ quadratic (slow for large n)

Week 3 trains you to ask:  
> â€œWhat happens when the input grows huge?â€

---

## ğŸ—³ï¸ Problem Sets â€“ Voting Systems

### âœ”ï¸ `plurality.c`

Implements a simple **plurality election**, where:

- each voter chooses **one** candidate  
- the candidate with the **most votes** wins  
- ties are allowed and all winners are printed

Concepts used:

- arrays of structs to represent candidates  
- updating vote counts  
- validating votes  
- scanning for the maximum

---

### âœ”ï¸ `runoff.c`

Implements a **preferential (instant-runoff) election**, where:

- each voter ranks candidates in order of preference  
- rounds are simulated:
  - count each voterâ€™s top non-eliminated candidate  
  - if no one has > 50%, eliminate the candidate(s) with fewest votes  
  - repeat until a candidate has a majority or a tie remains

This problem uses:

- 2D arrays for voter preferences  
- structs for candidate data  
- repeated rounds of counting + elimination  
- loop-based simulation of a real election system

Itâ€™s one of the most complex logic problems in the first half of the course.

---

## ğŸ“ Personal Notes

Key ideas I took from Week 3:

- A correct solution can still be â€œbadâ€ if itâ€™s too slow.  
- Data structure choice (arrays, structs) and algorithm choice (search/sort) are inseparable.  
- Real-world systems like elections can be modeled as algorithms.  
- Breaking down a big simulation (like runoff) into steps makes it manageable:
  - record preferences  
  - tabulate votes  
  - check for winner  
  - find minimum  
  - detect tie  
  - eliminate and repeat

---

## ğŸ“‚ Planned Files

```text
week3/
â”œâ”€â”€ README.md
â”œâ”€â”€ plurality.c
â””â”€â”€ runoff.c
